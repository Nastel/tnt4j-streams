#package com.jkoolcloud.tnt4j.streams.configure
WsConfigParserHandler.element.must.have.one=Element ''{0}'' must have at least one ''{1}'' child element defined{2}
WsConfigParserHandler.element.has.multiple=Element ''{0}'' can have only one definition of ''{1}'' or ''{2}'' child elements{3}
WsConfigParserHandler.attr.missing.or.illegal=Element ''{0}'' attribute ''{1}'' value ''{2}'' is illegal{3}

#package com.jkoolcloud.tnt4j.streams.inputs
AbstractWsStream.error.closing.scheduler=Error while shutting down Quartz scheduler\: {0}
AbstractWsStream.no.scenarios.defined=No scenarios/steps defined for ''{0}'' stream
AbstractWsStream.stream.scenarios.loaded=Stream ''{0}'' loaded {1} scenarios\!..
AbstractWsStream.scheduler.started=Stream ''{0}'' scheduler started. Loading scenarios...
AbstractWsStream.null.scheduler=Stream ''{0}'' scheduler is not initialized!..
AbstractWsStream.filling.req.data.variable=Filling in variable ''{0}'' value: {1}
AbstractWsStream.stream.step.start.delayed=Stream ''{0}'' scenario step ''{1}'' start delayed for {2} {3} from now
AbstractWsStream.stream.step.disabled=Stream ''{0}'' scenario step ''{1}:{2}'' execution has been disabled from configuration...
AbstractWsStream.scheduler.removed.inactive.job=Stream ''{0}'' scheduler removed inactive job ''{1}''
AbstractWsStream.scheduler.removed.inactive.jobs=Stream ''{0}'' scheduler removed {1} inactive jobs, {2} left to run
AbstractWsStream.stream.scheduling.job=Stream ''{0}'' scheduling job ''{1}''
AbstractWsStream.semaphore.acquired.stream=Acquired requests synchronization semaphore for stream ''{0}'' request ''{1}''
AbstractWsStream.semaphore.acquired.step=Acquired requests synchronization semaphore for scenario step ''{0}'' request ''{1}''
AbstractWsStream.semaphore.release=Released requests synchronization semaphore for ''{0}'' request ''{1}''
AbstractWsStream.currently.executing=Found scheduler currently executing tasks: {0}
AbstractWsStream.scheduler.triggers=Found scheduler triggers: {0}
AbstractWsStream.scheduler.trigger=Trigger: {0} {1}-{2}
AbstractWsStream.active.trigger=Found active trigger: {0}
AbstractWsStream.inactive.scheduler=Found inactive stream scheduler: {0}
AbstractWsStream.void.request=Void request\: id=''{0}'', reason=''{1}''. Skipping...
AbstractWsStream.condition.match.failed=Request ''{0}'' condition ''{1}'' match expression evaluation failed\: {2}
AbstractWsStream.condition.match=Matched condition ''{0}'' having resolution ''{1}''
AbstractWsStream.response.in.progress=Response ''{0}'' is currently parsed! Skipping new request invocation...
AbstractWsStream.response.pending=Response ''{0}'' is pending on input buffer! Skipping new request invocation...
AbstractWsStream.response.consumption.null=Response consumption check\: response is ''null''
AbstractWsStream.response.consumption.drop=Response consumption check\: dropping recurrent response ''{0}''
AbstractWsStream.expr.evaluation.failed=Failed to evaluate expression ''{0}''\: {1}
AbstractWsStream.expr.script=Variable expression ''{0}'' composed script\: {1}
AbstractWsStream.expr.compose.failed=Failed to compose groovy script for variable expression\: {0}

CmdStream.cant.execute.cmd=Can not invoke system command\: cmd={0}
CmdStream.invoking.command=Invoking system command\: url={0}
CmdStream.execute.exception=Stream ''{0}'' encountered error while executing system command for request''{1}''\: {2}
CmdStream.received.response=Received system command response\: respDat={0}

RestStream.cant.execute.get.request=Can not invoke RESTful service GET request\: url={0}
RestStream.invoking.get.request=Invoking RESTful service GET request\: url={0}
RestStream.cant.execute.post.request=Can not invoke RESTful service POST request\: url={0}
RestStream.invoking.post.request=Invoking RESTful service POST request\: url={0}, reqData={1}
RestStream.execute.exception=Stream ''{0}'' encountered error while performing RESTful service request ''{1}''\: {2}
RestStream.received.response=Received RESTful service response\: url={0}, respData={1}
RestStream.client.null=Can not execute request\: client is ''null''
RestStream.header.param.null=Empty request header parameter at position {0}
RestStream.invalid.request.uri=Invalid request URI

WsStream.cant.execute.request=Can not invoke WebService request\: url={0}
WsStream.execute.exception=Stream ''{0}'' encountered error while performing WebService request ''{1}''\: {2}
WsStream.invoking.request.raw=Invoking WebService RAW request\: url={0}, reqData={1}
WsStream.invoking.request.prep=Invoking WebService prepared request\: url={0}, reqData={1}
WsStream.received.response=Received WebService response\: url={0}, respData={1}
WsStream.received.failure.response=WebService failure response content\: url={0}, failure={1}
WsStream.disable.ssl.failed=Failed to disable SSL verification\: {0}

CastIronStream.login.request=Performing LOGIN step request\:\n{0}
CastIronStream.login.response=Got LOGIN step response\:\n{0}
CastIronStream.login.failed=LOGIN step failed\: {0}
CastIronStream.parser.tag.resolved=Will be parsed by parser having tag\: {0}
CastIronStream.parser.tag.resolve.failed=Failed to resolve parser tag\: reason={0}, SOAPMsg={1}
CastIronStream.adding.req.header=Adding request header\: header={0}, value={1}
CastIronStream.logged.in.after.fault=Logged in after scenario ''{0}'' received SOAP fault\: newToken={1}
CastIronStream.empty.login.step=Scenario ''{0}'' ''Login'' step is not defined...

JDBCStream.resetting.thread.count.property=ResultSet can''t be accessed from multiple threads! Resetting executor service threads count from {0} to 1.
JDBCStream.db.conn.not.defined=JDBC connection for request ''{0}'' is not defined!..
JDBCStream.query.not.defined=JDBC query for request ''{0}'' is not defined!..
JDBCStream.obtaining.db.connection=Obtaining DB connection for\: url={0}
JDBCStream.db.connection.obtained=DB connection obtained for\: url={0}, duration={1}
JDBCStream.preparing.query=Preparing SQL query\: request={0}, query={1}
JDBCStream.executing.query=Executing SQL query\: request={0}, url={1}
JDBCStream.query.execution.completed=SQL query execution completed\: url={0}, request={1}, exec.duration={2}, invoke.duration={3}
JDBCStream.execute.exception=Stream ''{0}'' encountered error while performing JDBC call request ''{1}''\: {2}
JDBCStream.rs.consumption.done=ResultSet consumption check for request ''{0}''\: ResultSet consumed at row {1}
JDBCStream.rs.consumption.marker.new=ResultSet consumption check for request ''{0}''\: cursor set at row {1}
JDBCStream.rs.consumption.exception=ResultSet consumption check for request ''{0}''\: exception occurred \: {1}
JDBCStream.failed.to.set.query.parameter=Failed to set request ''{0}'' SQL query parameter\: {1}
JDBCStream.set.query.parameter.null=Set SQL query parameter value ''null''\: request={0}, index={1}, type={2}
JDBCStream.set.query.parameter=Set SQL query parameter value\: request={0}, index={1}, value={2}, type={3}

#package com.jkoolcloud.tnt4j.streams.parsers
ActivityJDBCResultSetParser.adding.mapping=Adding SQL-Java types mapping {1}
ActivityJDBCResultSetParser.resolve.class.failed=Failed to resolve object class\: className={0}, reason={1}
ActivityJDBCResultSetParser.sql.exception=Exception occurred while accessing ResultSet row [{0}] column [{1}]
ActivityJDBCResultSetParser.driver.type.mappings.failed=Failed to retrieve JDBC driver defined SQL-Java type mappings\: {0}
ActivityJDBCResultSetParser.sql.type.value.resolution.failed=Failed to resolve real value from SQL type ''{0}''\: {1}
ActivityJDBCResultSetParser.value.resolution.using.types.map.failed=Failed to resolve ResultSet column ''{0}'' object value using types mapping. Will fall back to simple object value resolution: {1}
